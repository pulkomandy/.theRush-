//////////////////////////////////////////////////////////////////////////////////////////////
/*
	FSMClientLanChoseShip State machine
	
	File generated 01/02/2010 at 15:47:37
	
	Do not edit this file directly.
	Use Rapido! by Cedric Guillemet.
	
	Rapido! is licensed under GPLV2. Here is a copy of Rapido! License :
	
	This program is free software; you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation; version 2 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.
	
*/
//////////////////////////////////////////////////////////////////////////////////////////////

#ifndef FSMClientLanChoseShip_H__
#define FSMClientLanChoseShip_H__

///////////////////////////////////////////////////////////////////////////////////////////////////

#include "../libbase/ZFSM.h"

#include "FSMClientRaceStart.h"

///////////////////////////////////////////////////////////////////////////////////////////////////

enum {
Type_PlayerAskedSlot,
Type_PlayerAskedSpectator,
Type_LCSGotSlot,
Type_ShipSelected,
Type_CountDownStarts

};

///////////////////////////////////////////////////////////////////////////////////////////////////




/*

*/
typedef struct PlayerAskedSlot
{

} PlayerAskedSlot;




/*

*/
typedef struct PlayerAskedSpectator
{

} PlayerAskedSpectator;




/*

*/
typedef struct LCSGotSlot
{

} LCSGotSlot;




/*

*/
typedef struct ShipSelected
{

} ShipSelected;




/*

*/
typedef struct CountDownStarts
{

} CountDownStarts;



///////////////////////////////////////////////////////////////////////////////////////////////////

class FSMClientLanChoseShip : public ZFSM
{
public:
	FSMClientLanChoseShip()
	{
		Init();
	}
	
	void Init()
	{
		mGame = NULL;
mbCountDownStarts = false;
		mState = Undefined;
		EnterUndefined();	
	}

	//////////////////////////////////////////////////////////////////////////////////////////////
	void Tick(float timeEllapsed);

	//////////////////////////////////////////////////////////////////////////////////////////////
	

	//////////////////////////////////////////////////////////////////////////////////////////////
	void Handle(const PlayerAskedSlot& mes)
{
	switch(mState)
	{
		case PlayerOrSpectator:
			HandlePlayerOrSpectator(mes);
			break;
		case Spectator:
			HandleSpectator(mes);
			break;
		case WaitingForSlot:
			HandleWaitingForSlot(mes);
			break;
		case ChosingShip:
			HandleChosingShip(mes);
			break;
		case WaitingForCountDown:
			HandleWaitingForCountDown(mes);
			break;
		case RaceStarts:
			HandleRaceStarts(mes);
			break;
		case Undefined:
			HandleUndefined(mes);
			break;
	}
}

void Handle(const PlayerAskedSpectator& mes)
{
	switch(mState)
	{
		case PlayerOrSpectator:
			HandlePlayerOrSpectator(mes);
			break;
		case Spectator:
			HandleSpectator(mes);
			break;
		case WaitingForSlot:
			HandleWaitingForSlot(mes);
			break;
		case ChosingShip:
			HandleChosingShip(mes);
			break;
		case WaitingForCountDown:
			HandleWaitingForCountDown(mes);
			break;
		case RaceStarts:
			HandleRaceStarts(mes);
			break;
		case Undefined:
			HandleUndefined(mes);
			break;
	}
}

void Handle(const LCSGotSlot& mes)
{
	switch(mState)
	{
		case PlayerOrSpectator:
			HandlePlayerOrSpectator(mes);
			break;
		case Spectator:
			HandleSpectator(mes);
			break;
		case WaitingForSlot:
			HandleWaitingForSlot(mes);
			break;
		case ChosingShip:
			HandleChosingShip(mes);
			break;
		case WaitingForCountDown:
			HandleWaitingForCountDown(mes);
			break;
		case RaceStarts:
			HandleRaceStarts(mes);
			break;
		case Undefined:
			HandleUndefined(mes);
			break;
	}
}

void Handle(const ShipSelected& mes)
{
	switch(mState)
	{
		case PlayerOrSpectator:
			HandlePlayerOrSpectator(mes);
			break;
		case Spectator:
			HandleSpectator(mes);
			break;
		case WaitingForSlot:
			HandleWaitingForSlot(mes);
			break;
		case ChosingShip:
			HandleChosingShip(mes);
			break;
		case WaitingForCountDown:
			HandleWaitingForCountDown(mes);
			break;
		case RaceStarts:
			HandleRaceStarts(mes);
			break;
		case Undefined:
			HandleUndefined(mes);
			break;
	}
}

void Handle(const CountDownStarts& mes)
{
	switch(mState)
	{
		case PlayerOrSpectator:
			HandlePlayerOrSpectator(mes);
			break;
		case Spectator:
			HandleSpectator(mes);
			break;
		case WaitingForSlot:
			HandleWaitingForSlot(mes);
			break;
		case ChosingShip:
			HandleChosingShip(mes);
			break;
		case WaitingForCountDown:
			HandleWaitingForCountDown(mes);
			break;
		case RaceStarts:
			HandleRaceStarts(mes);
			break;
		case Undefined:
			HandleUndefined(mes);
			break;
	}
}



	//////////////////////////////////////////////////////////////////////////////////////////////
public:

	enum STATE
	{
	PlayerOrSpectator,
Spectator,
WaitingForSlot,
ChosingShip,
WaitingForCountDown,
RaceStarts,
Undefined

	};

	//////////////////////////////////////////////////////////////////////////////////////////////
	
	STATE mState;
	ZRushGame *mGame;
FSMClientRaceStart mFSMClientRaceStart;
bool mbCountDownStarts;

	//////////////////////////////////////////////////////////////////////////////////////////////
	
	void SetState(STATE newState)
	{
			switch(mState)
	{
		case PlayerOrSpectator:
			LeavePlayerOrSpectator();
			break;
		case Spectator:
			LeaveSpectator();
			break;
		case WaitingForSlot:
			LeaveWaitingForSlot();
			break;
		case ChosingShip:
			LeaveChosingShip();
			break;
		case WaitingForCountDown:
			LeaveWaitingForCountDown();
			break;
		case RaceStarts:
			LeaveRaceStarts();
			break;
		case Undefined:
			LeaveUndefined();
			break;
	}
mState = newState;	switch(newState)
	{
		case PlayerOrSpectator:
			EnterPlayerOrSpectator();
			break;
		case Spectator:
			EnterSpectator();
			break;
		case WaitingForSlot:
			EnterWaitingForSlot();
			break;
		case ChosingShip:
			EnterChosingShip();
			break;
		case WaitingForCountDown:
			EnterWaitingForCountDown();
			break;
		case RaceStarts:
			EnterRaceStarts();
			break;
		case Undefined:
			EnterUndefined();
			break;
	}
		
	}
	
	//////////////////////////////////////////////////////////////////////////////////////////////
	
	inline void TickPlayerOrSpectator(float timeEllapsed)
{


}
inline void TickSpectator(float timeEllapsed)
{


}
inline void TickWaitingForSlot(float timeEllapsed)
{


}
inline void TickChosingShip(float timeEllapsed)
{


}
inline void TickWaitingForCountDown(float timeEllapsed)
{


}
inline void TickRaceStarts(float timeEllapsed)
{

mFSMClientRaceStart.Tick(timeEllapsed);
}
inline void TickUndefined(float timeEllapsed)
{


}

	
	//////////////////////////////////////////////////////////////////////////////////////////////
	
	inline void EnterPlayerOrSpectator()
{

GProtoGui->BuildSpectatorPlayerGui();

}
inline void EnterSpectator()
{

GProtoGui->ShowSpectator();
mGame->AllowInGameMenu(true);
}
inline void EnterWaitingForSlot()
{


}
inline void EnterChosingShip()
{

gCameraMotion.SetCameraOrbitingClose(mGame->GetClientShip()->GetTransform());
GProtoGui->ShowLanShipSelection();

}
inline void EnterWaitingForCountDown()
{


}
inline void EnterRaceStarts()
{

mFSMClientRaceStart.mGame = mGame;
mFSMClientRaceStart.SetState(FSMClientRaceStart::Count3);
}
inline void EnterUndefined()
{


}

	
	//////////////////////////////////////////////////////////////////////////////////////////////
	
	inline void LeavePlayerOrSpectator()
{


}
inline void LeaveSpectator()
{


}
inline void LeaveWaitingForSlot()
{


}
inline void LeaveChosingShip()
{


}
inline void LeaveWaitingForCountDown()
{


}
inline void LeaveRaceStarts()
{


}
inline void LeaveUndefined()
{


}

	
	//////////////////////////////////////////////////////////////////////////////////////////////
	
	void HandlePlayerOrSpectator(const PlayerAskedSlot& mes)
{
//Ask slot message
mGame->SendNetMessage(ZNMSG_AskSlot());

SetState(WaitingForSlot);
mGame->AllowInGameMenu(false);
}

void HandlePlayerOrSpectator(const PlayerAskedSpectator& mes)
{
SetState(Spectator);
}

void HandlePlayerOrSpectator(const LCSGotSlot& mes)
{

}

void HandlePlayerOrSpectator(const ShipSelected& mes)
{

}

void HandlePlayerOrSpectator(const CountDownStarts& mes)
{
SetState(Spectator);
}

void HandleSpectator(const PlayerAskedSlot& mes)
{
//Ask slot message
mGame->SendNetMessage(ZNMSG_AskSlot());

SetState(WaitingForSlot);
mGame->AllowInGameMenu(false);
}

void HandleSpectator(const PlayerAskedSpectator& mes)
{

}

void HandleSpectator(const LCSGotSlot& mes)
{

}

void HandleSpectator(const ShipSelected& mes)
{

}

void HandleSpectator(const CountDownStarts& mes)
{

}

void HandleWaitingForSlot(const PlayerAskedSlot& mes)
{

}

void HandleWaitingForSlot(const PlayerAskedSpectator& mes)
{

}

void HandleWaitingForSlot(const LCSGotSlot& mes)
{
SetState(ChosingShip);

}

void HandleWaitingForSlot(const ShipSelected& mes)
{

}

void HandleWaitingForSlot(const CountDownStarts& mes)
{

}

void HandleChosingShip(const PlayerAskedSlot& mes)
{

}

void HandleChosingShip(const PlayerAskedSpectator& mes)
{

}

void HandleChosingShip(const LCSGotSlot& mes)
{

}

void HandleChosingShip(const ShipSelected& mes)
{
if (!mbCountDownStarts)
    GProtoGui->ShowWaitingForPlayers();

mGame->AllowInGameMenu(true);

SetState(WaitingForCountDown);
}

void HandleChosingShip(const CountDownStarts& mes)
{
mbCountDownStarts = true;
GProtoGui->ValidateLanSelShip();
SetState(RaceStarts);
}

void HandleWaitingForCountDown(const PlayerAskedSlot& mes)
{

}

void HandleWaitingForCountDown(const PlayerAskedSpectator& mes)
{

}

void HandleWaitingForCountDown(const LCSGotSlot& mes)
{

}

void HandleWaitingForCountDown(const ShipSelected& mes)
{

}

void HandleWaitingForCountDown(const CountDownStarts& mes)
{
// Hard wired code
//GProtoGui->ValidateLanSelShip();
SetState(RaceStarts);
}

void HandleRaceStarts(const PlayerAskedSlot& mes)
{

}

void HandleRaceStarts(const PlayerAskedSpectator& mes)
{

}

void HandleRaceStarts(const LCSGotSlot& mes)
{

}

void HandleRaceStarts(const ShipSelected& mes)
{

}

void HandleRaceStarts(const CountDownStarts& mes)
{

}

void HandleUndefined(const PlayerAskedSlot& mes)
{

}

void HandleUndefined(const PlayerAskedSpectator& mes)
{

}

void HandleUndefined(const LCSGotSlot& mes)
{

}

void HandleUndefined(const ShipSelected& mes)
{

}

void HandleUndefined(const CountDownStarts& mes)
{

}


	
	//////////////////////////////////////////////////////////////////////////////////////////////
};

///////////////////////////////////////////////////////////////////////////////////////////////////

inline void FSMClientLanChoseShip::Tick(float timeEllapsed)
{
	ZFSM::Tick(timeEllapsed);
	
		switch(mState)
	{
		case PlayerOrSpectator:
			TickPlayerOrSpectator(timeEllapsed);
			break;
		case Spectator:
			TickSpectator(timeEllapsed);
			break;
		case WaitingForSlot:
			TickWaitingForSlot(timeEllapsed);
			break;
		case ChosingShip:
			TickChosingShip(timeEllapsed);
			break;
		case WaitingForCountDown:
			TickWaitingForCountDown(timeEllapsed);
			break;
		case RaceStarts:
			TickRaceStarts(timeEllapsed);
			break;
		case Undefined:
			TickUndefined(timeEllapsed);
			break;
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////

#endif

