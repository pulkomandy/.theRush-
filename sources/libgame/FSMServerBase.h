//////////////////////////////////////////////////////////////////////////////////////////////
/*
	FSMServerBase State machine
	
	File generated 01/02/2010 at 15:47:37
	
	Do not edit this file directly.
	Use Rapido! by Cedric Guillemet.
	
	Rapido! is licensed under GPLV2. Here is a copy of Rapido! License :
	
	This program is free software; you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation; version 2 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.
	
*/
//////////////////////////////////////////////////////////////////////////////////////////////

#ifndef FSMServerBase_H__
#define FSMServerBase_H__

///////////////////////////////////////////////////////////////////////////////////////////////////

#include "../libbase/ZFSM.h"

#include "../libplatform/ZenFWManager.h"
#include "FSMServerClassicRace.h"
#include "../libgame/ZRushTrack.h"

///////////////////////////////////////////////////////////////////////////////////////////////////

enum {
Type_NewGameSet

};

///////////////////////////////////////////////////////////////////////////////////////////////////




/*

*/
typedef struct NewGameSet
{

} NewGameSet;



///////////////////////////////////////////////////////////////////////////////////////////////////

class FSMServerBase : public ZFSM
{
public:
	FSMServerBase()
	{
		Init();
	}
	
	void Init()
	{
		
		mState = InitialState;
		EnterInitialState();	
	}

	//////////////////////////////////////////////////////////////////////////////////////////////
	void Tick(float timeEllapsed);

	//////////////////////////////////////////////////////////////////////////////////////////////
	

	//////////////////////////////////////////////////////////////////////////////////////////////
	void Handle(const NewGameSet& mes)
{
	switch(mState)
	{
		case InitialState:
			HandleInitialState(mes);
			break;
		case LoadingMap:
			HandleLoadingMap(mes);
			break;
		case ReadyForGame:
			HandleReadyForGame(mes);
			break;
	}
}



	//////////////////////////////////////////////////////////////////////////////////////////////
public:

	enum STATE
	{
	InitialState,
LoadingMap,
ReadyForGame

	};

	//////////////////////////////////////////////////////////////////////////////////////////////
	
	STATE mState;
	ZRushGame *mGame;
FSMServerClassicRace mFSMServerClassicRace;

	//////////////////////////////////////////////////////////////////////////////////////////////
	
	void SetState(STATE newState)
	{
			switch(mState)
	{
		case InitialState:
			LeaveInitialState();
			break;
		case LoadingMap:
			LeaveLoadingMap();
			break;
		case ReadyForGame:
			LeaveReadyForGame();
			break;
	}
mState = newState;	switch(newState)
	{
		case InitialState:
			EnterInitialState();
			break;
		case LoadingMap:
			EnterLoadingMap();
			break;
		case ReadyForGame:
			EnterReadyForGame();
			break;
	}
		
	}
	
	//////////////////////////////////////////////////////////////////////////////////////////////
	
	inline void TickInitialState(float timeEllapsed)
{


}
inline void TickLoadingMap(float timeEllapsed)
{

if (LoadingPipeIsEmpty())
    SetState(ReadyForGame);
}
inline void TickReadyForGame(float timeEllapsed)
{

switch( mGame->GetGameSet().mGameType)
{
case 0: //Raw
break;
case 1: // Classic Race
mFSMServerClassicRace.Tick(timeEllapsed);
break;

}
}

	
	//////////////////////////////////////////////////////////////////////////////////////////////
	
	inline void EnterInitialState()
{


}
inline void EnterLoadingMap()
{

mGame->HandleNewGameSet();
}
inline void EnterReadyForGame()
{

mGame->HandleLoadingDone();
mGame->SendNetMessage(ZNMSG_SlotsAvailable(GTrack->GetSpawnMatrices().size()));
switch( mGame->GetGameSet().mGameType)
{
case 0: //Raw
break;
case 1: // Classic Race
mFSMServerClassicRace.mGame = mGame;
mFSMServerClassicRace.SetState(FSMServerClassicRace::WaitingEnoughPlayer);
break;

}
}

	
	//////////////////////////////////////////////////////////////////////////////////////////////
	
	inline void LeaveInitialState()
{


}
inline void LeaveLoadingMap()
{


}
inline void LeaveReadyForGame()
{


}

	
	//////////////////////////////////////////////////////////////////////////////////////////////
	
	void HandleInitialState(const NewGameSet& mes)
{
SetState(LoadingMap);
}

void HandleLoadingMap(const NewGameSet& mes)
{

}

void HandleReadyForGame(const NewGameSet& mes)
{
SetState(LoadingMap);
}


	
	//////////////////////////////////////////////////////////////////////////////////////////////
};

///////////////////////////////////////////////////////////////////////////////////////////////////

inline void FSMServerBase::Tick(float timeEllapsed)
{
	ZFSM::Tick(timeEllapsed);
	
		switch(mState)
	{
		case InitialState:
			TickInitialState(timeEllapsed);
			break;
		case LoadingMap:
			TickLoadingMap(timeEllapsed);
			break;
		case ReadyForGame:
			TickReadyForGame(timeEllapsed);
			break;
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////

#endif

